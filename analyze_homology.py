import argparse
import json
from operator import contains
from re import sub
import sys
import csv
import json
import os
import jsonpickle
from bacvax_homology_common import *

parser = argparse.ArgumentParser(description="BacVax Homology Analyzer")
parser.add_argument("-w", "--window", help="Window length to match against (e.g. 5)", type=int, required=True)
parser.add_argument("-s", "--sequence", help="Input sequence to analyze", type=str, required=True)
parser.add_argument("-l", "--lookupfile", help="Path to lookup table file generated by generate_lookup_table.py. By default, the script will look for the default output of the script ('lookup_{w}.json' in the data subdirectory where w=window length", type=str)
parser.add_argument("-o", "--output", help="Path to CSV file to write structured results to", required=True)

args=parser.parse_args()

window: int=args.window
sequence: str=args.sequence
lookupfile: str=args.lookupfile
outputfile: str=args.output

if window == None:
    parser.print_help()
    sys.exit(0)

if sequence == None:
    parser.print_help()
    sys.exit(0)

if lookupfile == None:
    lookupfile=f'./data/lookup_{window}.json'

if not os.path.exists(lookupfile):
    print(f"Unable to find input file {os.path.abspath(lookupfile)}")
    sys.exit(0)

if not outputfile==None and not outputfile.endswith(".csv"):
    print(f"Results file {os.path.abspath(outputfile)} must be a csv file")

class result(object):
    def __init__(self, entry: str, matched_sequence: str, idx_input_sequence: int, idx_entry_sequence: int):
        self.entry=entry
        self.matched_sequence=matched_sequence
        self.idx_input_sequence=idx_input_sequence
        self.idx_entry_sequence=idx_entry_sequence
    entry: str
    matched_sequence: str
    idx_input_sequence: int
    idx_entry_sequence: int

results: list[result]=[]

print(f"Loading lookup table from {os.path.abspath(lookupfile)}")

lookup: lookup_table = lookup_table()
with open(lookupfile, 'r') as data:
    json_data = data.read()

lookup.fromJSON(json_data)

print(f"Successfully loaded lookup table")

for idx in range(0, len(sequence)-window+1):
    lookup_sequence=sequence[idx:idx+window]
    print(f"Analyzing sequence {lookup_sequence}")
    matches=0
    if not lookup_sequence in lookup:
        continue
    for val in lookup[lookup_sequence]:
        val: sequence_match = val
        matches=matches+1
        results.append(result(val.e, lookup_sequence, idx_input_sequence=idx, idx_entry_sequence=val.o))
    print(f'Lookup sequence {lookup_sequence} matched {matches} subsequences in the human genome')

print(f'Found {len(results)} matches for window length={window}')

# Write results to CSV if requested
if len(results) > 0 and not outputfile==None:
    print(f"Writing results to {os.path.abspath(outputfile)}...")
    if os.path.exists(outputfile):
        os.remove(outputfile)
    with open(outputfile, 'w') as csvfile:
        writer=csv.DictWriter(csvfile, fieldnames=['Matched Sequence', 'Index in Input Sequence (0-based)', 'Entry', 'Index in Entry Sequence (0-based)'])
        writer.writeheader()
        for a_result in results:
            writer.writerow({'Matched Sequence': a_result.matched_sequence, 'Index in Input Sequence (0-based)': a_result.idx_input_sequence, 'Entry': a_result.entry, 'Index in Entry Sequence (0-based)': a_result.idx_entry_sequence })

print("Hold tight - cleaning up...")
